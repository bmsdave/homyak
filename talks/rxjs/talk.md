# Категории языков программирования:

https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BF%D0%BE_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F%D0%BC

### Аспектно-ориентированное программирование ??
https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5

AspectJ
AspectLua (расширение Lua)
CaesarJ
Compose*
ObjectTeams

### Структурное программирование 

https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5

Basic
Cg
JOVIAL
Pascal
PL/M
QBASIC
REXX
Активный Оберон
Алгол 68
Алгол
sh
Модула
Оберон
ПЛ/1
Упрощённый Алгол
Фокал
Фортран

###  Процедурное программирование 

Процеду́рное программи́рование — программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка[1].

Процедурное программирование является отражением архитектуры традиционных ЭВМ, которая была предложена Фон Нейманом в 1940-х годах. Теоретической моделью процедурного программирования служит абстрактная вычислительная система под названием машина Тьюринга.

GNU bc
Euphoria
Limbo
Lua
Maple
MATLAB
Occam
PureBasic — компилируемая модификация Basic
Scilab
Активный Оберон
Алгол
Би
КОБОЛ
Модула-2
Модула-3
Оберон
Паскаль
Рапира
Си

### Логическое программирование

Логи́ческое программи́рование — парадигма программирования, основанная на автоматическом доказательстве теорем, а также раздел дискретной математики, изучающий принципы логического вывода информации на основе заданных фактов и правил вывода. Логическое программирование основано на теории и аппарате математической логики с использованием математических принципов резолюций.

Mercury
Prolog

### Объектно-ориентированное программирование

Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса[1], а классы образуют иерархию наследования[2][3].

Action Script
C++/CLI
C++
ColdFusion
D
Delphi
Dylan
Eiffel
Game Maker Language (GML)
Groovy
haXe
Io
Java
JavaScript
MC#
Object Pascal
Objective-C
Perl
PHP
Pike
Python
Ruby
Self
Simula
Smalltalk
Swift
Vala
Visual Basic
Visual DataFlex
Zonnon
Ada
Активный Оберон
Компонентный Паскаль
Модула-3
Оберон-2

### Функциональное программирование

Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).

Cat
Clean
Dylan
Erlang
F#
Gentee
Haskell
Hope
J
Mathematica
OCaml
Scheme
АПЛ
Лисп
Лого
РЕФАЛ

### Мультипарадигмальный язык программирования

Мультипарадигма́льный язы́к программи́рования — как правило, язык программирования, который был разработан специально как инструмент мультипарадигмального программирования, то есть изобразительные возможности которого изначально предполагалось унаследовать от нескольких, чаще всего не родственных языков.

C#
Curry
Delphi (язык программирования)
Erlang
Mathematica
Mozart
Nemerle
Python
Scala
Zonnon
Активный Оберон
Компонентный Паскаль (Component Pascal)
Модула-3


# Парадигмы программирования
https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F

Паради́гма программи́рования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером[1].

```
Слово «парадигма» используется в программировании для определения семейства обозначений (нотаций), разделяющих общий способ (методику) реализаций программ.

(c) Спинеллис, Диомидис
```

### Основные модели программирования

 * Императивное программирование
 * Декларативное программирование
 * Структурное программирование
 * Функциональное программирование
 * Логическое программирование
 * Объектно-ориентированное программирование
   * Программирование, основанное на классах
   * Программирование, основанное на прототипах
   * Субъектно-ориентированное программирование


### Подходы и приёмы программирования

 * Структурное программирование
 * Процедурное программирование
 * Аппликативное программирование
 * Обобщённое программирование
 * Доказательное программирование
 * Порождающее программирование
 * Аспектно-ориентированное программирование
 * Агентно-ориентированное программирование
 * Рекурсия
 * Автоматное программирование
 * Событийно-ориентированное программирование
 * Компонентно-ориентированное программирование
 * Грамотное программирование
 

# Реактивное программирование

Реактивное программирование — парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.
К примеру, в императивном программировании присваивание a := b + c будет означать, что переменной a будет присвоен результат выполнения операции b + c, используя текущие (на момент вычисления) значения переменных. Позже значения переменных b и c могут быть изменены без какого-либо влияния на значение переменной a.
В реактивном же программировании значение a будет автоматически пересчитано, основываясь на новых значениях.
Современные табличные процессоры представляют собой пример реактивного программирования. Ячейки таблицы могут содержать строковые значения или формулу вида «=B1+C1», значение которой будет вычислено исходя из значений соответствующих ячеек. Когда значение одной из зависимых ячеек будет изменено, значение этой ячейки будет автоматически обновлено.
Другой пример — это языки описания аппаратуры (HDL), такие как Verilog. Реактивное программирование позволяет моделировать изменения в виде их распространения внутри модели.
Реактивное программирование предлагалось как путь для лёгкого создания пользовательских интерфейсов, анимации или моделирования систем, изменяющихся во времени.
К примеру, в MVC архитектуре с помощью реактивного программирования можно реализовать автоматическое отражение изменений из Model в View и наоборот из View в Model.

## Реактивные подходы к программированию


### Императивное реактивное программирование
Можно соединить парадигмы реактивного и императивного программирования. В такой связке императивные программы могли бы работать над реактивными структурами данных.

### Объектно-ориентированное реактивное программирование
Объектно-ориентированное реактивное программирование (ООРП) — это комбинация объектно-ориентированного подхода с реактивным. Вероятно, наиболее естественный способ сделать это состоит в том, что вместо методов и полей, у объектов есть реакции, которые автоматически пересчитывают значения и другие реакции зависят от изменений этих значений.

### Функциональное реактивное программирование
Функциональное программирование является наиболее естественным базисом для реализации реактивной архитектуры, хорошо сочетаясь с параллелизмом.
Функциональное реактивное программирование (ФРП) сформировалось в 1997 году, с предложением языка Fran[1]. Позже были разработаны такие языки как Fruit, FRP и RT-FRP, FAL, Frob, Fvision, Yampa[2].
Простейшее функциональное реактивное выражение имеет следующую форму:
```
b1 `until` e => b2
```
что буквально означает «вести себя как b1 до возникновения события e, после этого вести себя как b2».


# паттерны 

http://public.jugru.org/holyjs/2016/spb/day_1/track_1/rusakovich.pdf

![alt tag](https://lh3.googleusercontent.com/-t7JXfsD7J_U/VKi1lbT5ZvI/AAAAAAAALms/g7-1psSs4pM/w800-h800/How%2Bto%2Buse%2BGOF%2BDesign%2BPatterns.gif)


# основные игроки реактивных библиотек
https://dou.ua/lenta/articles/reactive-libraries/

Observable, Observer, Subscriber
Давайте посмотрим на основных игроков реактивных библиотек: Observable, Observer и Subscriber.

Observable — это объект или функция, которая выдает последовательности данных во времени (a.k.a. The Producer).

Observer — это объект или функция, которая знает, как обрабатывать последовательности данных (a.k.a. The Consumer).

Subscriber — это объект или функция, которая связывает Observable и Observer.


Я думаю многие из работающих программистов, увидев это диаграмму, скажут, что мы это и так знаем — обычный messaging и pub-sub. Это и так, и не так:

Rx библиотеки заточены на асинхронную обработку без блокировки обработки данных.

Rx предлагает простой API с выделенными каналами для передачи данных, ошибок и сигнала об окончании потока данных.

В Rx библиотеках есть больше сотни операторов, которыми можно обрабатывать потоки идущие к подписчику. Операторы можно собирать в цепочки, т.е операторы composable.

В некоторых реализациях RX, например, RxJava2, хорошо поддерживается backpressure, т.е. ситуация, когда продюсер выдает данные быстрее, чем подписчик может обработать.

Для Rx messaging не нужно поднимать специальные серверы. Все включено в код вашего приложения.

В языках, которые поддерживают multi-threading, работа со threads упрощается, как и переключения с одних threads на другие. Разработчики на Андроиде — это оценят, ибо там вывод на экран всегда должен выполняться main thread, а вычисления — другими.

Как же все-таки Observable передает данные в Observer? Observer может имплементировать три метода (названия могут слегка отличаться в зависимости от языка):

next() - вот тебе новое значение из потока;

error() - вот тебе ошибка, произошедшая в потоке;

complete() - поток завершен.

В следующем примере функция getData() превращает массив с пивом в Observable и возвращает его. Кому? Подписчику, когда он появится. А подписчик — getData().subscribe(...​) - передает Observer, как аргумент функции subscribe(). Соответственно, Observer состоит из трех функций:

что делать, когда придет следующий элемент потока;

что делать, если придет ошибка;

что делать, если придет сигнал об окончании потока.


![alt tag](https://s.dou.ua/storage-files/operators.png)

# примеры из rxmarbles.com
http://rxmarbles.com/


# примеры из rxmarbles.com
